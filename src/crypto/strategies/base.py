"""Strategy base protocol and abstract class."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Any, Protocol, runtime_checkable

import pandas as pd

from crypto.core.types import Signal
from crypto.indicators.base import indicator_registry


@dataclass
class StrategySignal:
    """Signal generated by a strategy with metadata."""

    signal: Signal
    timestamp: datetime
    price: Decimal
    confidence: float = 1.0  # 0.0 to 1.0
    reason: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)


@runtime_checkable
class Strategy(Protocol):
    """
    Strategy protocol - implement this to create new strategies.
    
    This defines the interface that all trading strategies must implement.
    Strategies are config-driven and receive their parameters from YAML.
    """

    name: str

    def generate_signals(self, candles: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals from candle data.
        
        Args:
            candles: DataFrame with OHLCV data
                Expected columns: open, high, low, close, volume
                Index should be datetime
                
        Returns:
            Series of Signal enum values indexed by datetime
        """
        ...

    def get_parameters(self) -> dict[str, Any]:
        """
        Get strategy parameters for logging and optimization.
        
        Returns:
            Dictionary of parameter names to values
        """
        ...


class BaseStrategy(ABC):
    """
    Abstract base class for strategies.
    
    Provides common functionality and enforces the Strategy protocol.
    Subclass this and implement generate_signals().
    
    Config-driven parameters (from strategies.yaml):
    - stop_loss_pct: Optional stop loss override
    - take_profit_pct: Optional take profit override
    - trailing_stop_pct: Optional trailing stop override
    - use_adx_filter: Enable ADX trend filter
    - adx_threshold: ADX threshold for trend filter
    - use_volume_filter: Enable volume confirmation
    - volume_multiplier: Volume must be > avg * multiplier
    """

    name: str = "base_strategy"

    def __init__(self, **params: Any):
        """
        Initialize strategy with parameters.
        
        Parameters are typically loaded from config/strategies.yaml.
        
        Args:
            **params: Strategy-specific parameters
        """
        self._params = params
        
        # Extract risk management params (used by BacktestEngine)
        self.stop_loss_pct: Decimal | None = self._parse_decimal(params.get("stop_loss_pct"))
        self.take_profit_pct: Decimal | None = self._parse_decimal(params.get("take_profit_pct"))
        self.trailing_stop_pct: Decimal | None = self._parse_decimal(params.get("trailing_stop_pct"))
        
        # Extract filter params (used by strategies)
        self.use_adx_filter: bool = params.get("use_adx_filter", False)
        self.adx_threshold: int = params.get("adx_threshold", 25)
        self.use_volume_filter: bool = params.get("use_volume_filter", False)
        self.volume_multiplier: float = params.get("volume_multiplier", 1.5)
        
        self._setup(**params)
    
    @staticmethod
    def _parse_decimal(value: Any) -> Decimal | None:
        """Parse a value to Decimal, returning None if not provided."""
        if value is None:
            return None
        if isinstance(value, Decimal):
            return value
        return Decimal(str(value))

    def _setup(self, **params: Any) -> None:
        """
        Optional setup method for subclasses.
        
        Override this to process parameters during initialization.
        """
        pass

    @abstractmethod
    def generate_signals(self, candles: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals from candle data.
        
        Must be implemented by subclasses.
        
        Args:
            candles: DataFrame with OHLCV data
                
        Returns:
            Series of Signal enum values
        """
        pass

    def get_parameters(self) -> dict[str, Any]:
        """Get strategy parameters."""
        return self._params.copy()

    def validate_candles(self, candles: pd.DataFrame) -> None:
        """
        Validate that candles have required columns.
        
        Args:
            candles: DataFrame to validate
            
        Raises:
            ValueError: If required columns are missing
        """
        required = {"open", "high", "low", "close", "volume"}
        missing = required - set(candles.columns)
        if missing:
            raise ValueError(f"Missing required columns: {missing}")

    def create_signal_series(
        self,
        index: pd.DatetimeIndex,
        default: Signal = Signal.HOLD,
    ) -> pd.Series:
        """
        Create a signal series with a default value.
        
        Args:
            index: DatetimeIndex for the series
            default: Default signal value
            
        Returns:
            Series filled with default signal
        """
        return pd.Series(default, index=index)

    def compute_adx(self, candles: pd.DataFrame, period: int = 14) -> pd.Series:
        """
        Compute ADX indicator for trend strength filtering.
        
        Args:
            candles: OHLCV DataFrame
            period: ADX period
            
        Returns:
            Series with ADX values
        """
        return indicator_registry.compute("adx", candles, period=period)

    def compute_volume_filter(self, candles: pd.DataFrame, period: int = 20) -> pd.Series:
        """
        Compute volume filter (volume > avg * multiplier).
        
        Args:
            candles: OHLCV DataFrame
            period: Lookback period for average
            
        Returns:
            Boolean Series (True where volume condition is met)
        """
        volume = candles["volume"]
        volume_avg = volume.rolling(window=period).mean()
        return volume > (volume_avg * self.volume_multiplier)

    def apply_filters(
        self,
        signals: pd.Series,
        candles: pd.DataFrame,
    ) -> pd.Series:
        """
        Apply ADX and volume filters to signals.
        
        Filters out signals where conditions are not met.
        
        Args:
            signals: Original signal series
            candles: OHLCV DataFrame
            
        Returns:
            Filtered signal series
        """
        filtered = signals.copy()
        
        # Apply ADX filter (only allow signals when trend is strong)
        if self.use_adx_filter:
            try:
                adx = self.compute_adx(candles)
                weak_trend = adx < self.adx_threshold
                # Reset signals to HOLD where trend is weak
                filtered.loc[weak_trend] = Signal.HOLD
            except Exception:
                pass  # ADX computation failed, skip filter
        
        # Apply volume filter
        if self.use_volume_filter:
            volume_ok = self.compute_volume_filter(candles)
            # Reset signals to HOLD where volume is low
            filtered.loc[~volume_ok] = Signal.HOLD
        
        return filtered

    def __repr__(self) -> str:
        params_str = ", ".join(f"{k}={v}" for k, v in self._params.items())
        return f"{self.__class__.__name__}({params_str})"
