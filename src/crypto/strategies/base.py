"""Strategy base protocol and abstract class."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Any, Protocol, runtime_checkable

import pandas as pd

from crypto.core.types import Signal


@dataclass
class StrategySignal:
    """Signal generated by a strategy with metadata."""

    signal: Signal
    timestamp: datetime
    price: Decimal
    confidence: float = 1.0  # 0.0 to 1.0
    reason: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)


@runtime_checkable
class Strategy(Protocol):
    """
    Strategy protocol - implement this to create new strategies.
    
    This defines the interface that all trading strategies must implement.
    Strategies are config-driven and receive their parameters from YAML.
    """

    name: str

    def generate_signals(self, candles: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals from candle data.
        
        Args:
            candles: DataFrame with OHLCV data
                Expected columns: open, high, low, close, volume
                Index should be datetime
                
        Returns:
            Series of Signal enum values indexed by datetime
        """
        ...

    def get_parameters(self) -> dict[str, Any]:
        """
        Get strategy parameters for logging and optimization.
        
        Returns:
            Dictionary of parameter names to values
        """
        ...


class BaseStrategy(ABC):
    """
    Abstract base class for strategies.
    
    Provides common functionality and enforces the Strategy protocol.
    Subclass this and implement generate_signals().
    """

    name: str = "base_strategy"

    def __init__(self, **params: Any):
        """
        Initialize strategy with parameters.
        
        Parameters are typically loaded from config/strategies.yaml.
        
        Args:
            **params: Strategy-specific parameters
        """
        self._params = params
        self._setup(**params)

    def _setup(self, **params: Any) -> None:
        """
        Optional setup method for subclasses.
        
        Override this to process parameters during initialization.
        """
        pass

    @abstractmethod
    def generate_signals(self, candles: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals from candle data.
        
        Must be implemented by subclasses.
        
        Args:
            candles: DataFrame with OHLCV data
                
        Returns:
            Series of Signal enum values
        """
        pass

    def get_parameters(self) -> dict[str, Any]:
        """Get strategy parameters."""
        return self._params.copy()

    def validate_candles(self, candles: pd.DataFrame) -> None:
        """
        Validate that candles have required columns.
        
        Args:
            candles: DataFrame to validate
            
        Raises:
            ValueError: If required columns are missing
        """
        required = {"open", "high", "low", "close", "volume"}
        missing = required - set(candles.columns)
        if missing:
            raise ValueError(f"Missing required columns: {missing}")

    def create_signal_series(
        self,
        index: pd.DatetimeIndex,
        default: Signal = Signal.HOLD,
    ) -> pd.Series:
        """
        Create a signal series with a default value.
        
        Args:
            index: DatetimeIndex for the series
            default: Default signal value
            
        Returns:
            Series filled with default signal
        """
        return pd.Series(default, index=index)

    def __repr__(self) -> str:
        params_str = ", ".join(f"{k}={v}" for k, v in self._params.items())
        return f"{self.__class__.__name__}({params_str})"
